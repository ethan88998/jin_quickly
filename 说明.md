生成及解析JWT并应用
Json + web + token
JWT由三部分组成
Header: 加密方式+类型
Payload: 过期时间+ 账号
Signature: 能前面两部分加密

###特点：
1. JWT默认不加密，但可以密码
   2. 要用https加密传输
   3. 没有状态，签到后只的等待过期
   4. JWT请求头有加密方式，被窃取后能获取用户权限发，所以有效时间设置不会太长


### JWT流程
1. 密钥[]byte(“ethan25028350”)
   2. Jet.Regis
   3. Jwt.NewWh HS256加密 对称加密，企业级加密RS256 非对称
   4. Token.Signe

## 问题：
### 1.登录后如何显示账号列表？
    登录方法验证通过后，重定向跳转到账号列表
    c.redirect(http.StatusFound, “/admin/users”)

### 2. 如何在账号列表显示登录的账号？
    思路： 用户信息已经在JWT里-》 JWT中间件解析后放进Gin Context-》 页面handler取出来-》传给模板

    解析JWT：
    创建解析JWT的方法，传入JWT返回解析后的数据claims，claims里有UID，username /过期时间信息
    
    查询全部账号数据：
    1. c.Get(“username”)  获取解析JWT里的username
    2. 通过c.HTML渲染将username传送到前端

### 3.退出登录
    1.加个退出按钮Botton
    2.写个退出方法 c.SetCookie(自动输入了) 重定向到登录页/login 
    3.加个退出登录的路由 /logout，退出方法

### 4.JWT过期自动退出

## 完整数据流
      登录成功
      ↓
      JWT 生成（含 Username）
      ↓
      Set-Cookie(token)
      ↓
      访问 /admin/users
      ↓
      JWTAuth 中间件
      ├─ ParseToken
      ├─ c.Set("username", claims.Username)
      ↓
      Adminlist handler
      ├─ c.Get("username")
      ↓
      HTML 模板
      ├─ {{ .current }}

## 编辑功能数据流程
1. 点击编辑按钮
2. 地址栏变更 /admin/user/edit?id=${id}，触发 GetEditUserPage，访问编辑页
3. HTML编辑页触发 编辑JS <script src="/static/edit.js"></script>
3. 触发编辑JS
4. 编辑JS fetch(`/admin/user/edit/api?id=${id}`触发访问编辑数据方法
5. 数据方法返回果断数据
6. JS将数据填充到编辑页

## ✅ 编辑功能完整数据流程（规范说明版）
### 1️⃣ 点击编辑按钮（列表页）

      用户在用户列表页点击 「编辑」 按钮
      前端通过 JS 执行：
      
      window.location.href = `/admin/user/edit?id=${id}`
      👉 浏览器地址栏发生变化

### 2️⃣ 地址栏跳转，访问编辑页面路由
      浏览器访问：
      /admin/user/edit?id={id}
      Gin 路由匹配：
      admin.GET("/user/edit", hans.GetEditUserPage)
      后端返回 编辑页面 HTML（editN.html）

### 3️⃣ 编辑页 HTML 加载完成，触发 JS

      编辑页中包含：
      <script src="/static/edit.js"></script>
      浏览器行为：
      HTML 加载完成
      ↓
      加载 edit.js
      ↓
      自动执行 JS 代码

### 4️⃣ 编辑 JS 读取 URL 参数并请求数据接口
      const params = new URLSearchParams(window.location.search)
      const id = params.get("id")
      
      fetch(`/admin/user/edit/api?id=${id}`, {
      credentials: "include"
      })

### 5️⃣ 后端编辑数据接口返回 JSON

      Gin 路由：
      admin.GET("/user/edit/api", hans.EditUserApi)
      返回示例：
      
      {
      "code": 200,
      "data": {
      "username": "admin4",
      "age": 23,
      "email": "xxx@gmail.com"
      },
      "msg": "ok"
      }

📌 此接口只返回数据，不返回页面

### 6️⃣ 前端 JS 将数据填充到编辑页面
      document.getElementById("username").value = user.username
      document.getElementById("age").value = user.age
      document.getElementById("email").value = user.email
      👉 编辑页面完成数据回显

## JS 讲解
      const params = new URLSearchParams(window.location.search)
      const id = params.get("id")
      
      fetch(`/admin/user/edit/api?id=${id}`, {
      credentials: "include"
      })
      .then(res => res.json())
      .then(res => {
      if (res.code !== 200) {
      alert(res.msg)
      return
      }

        const user = res.data
        document.getElementById("username").value = user.username
        document.getElementById("age").value = user.age
        document.getElementById("email").value = user.email
    })

    .catch(err => {
    console.error("获取用户失败",err)
    alert("加载用户信息失败")
})

## 整体结构
      fetch(url, options)
      .then(处理第一次结果)
      .then(处理真正数据)
      .catch(出错了)

## 九、整段代码“人话翻译版”
      1. 浏览器向 /admin/user/edit/api?id=5 发请求
      2. 请求时带上 Cookie（JWT）
      3. 后端返回 JSON
      4. JS 把 JSON 解析成对象
      5. 判断业务是否成功
      6. 把用户信息填充到输入框
      7. 如果任何一步失败，提示错误

## ✅ 2️⃣ 状态码
      | 状态码 | 含义           |
      | --- | ------------ |
      | 200 | 成功           |
      | 400 | 参数错误         |
      | 401 | 未登录 / JWT 失效 |
      | 404 | 路由错误         |
      | 500 | 后端崩了         |

## 分页功能「数据」实现流程
      1. 函数实现查询总数据/分页显示
      2. 前端发起分布请求
         前端 -> HTTP 请求 -> 后端   
         GET /admin/users/api?page=1&pageSize=10
   
      3. 后端接收分页参数，查看结果
         后端接收 page / pagesize（字符串）
      4. 后端计算分页 offset = (page -1) * pageSaze
      5. 后端执行两次数据库操作
         5.1 第一次查 当前页数据
         LIMIT pageSize OFFSET offset
         5.2 查总数据
         SELECT COUNT(*)
         目的：告诉前端：一共有多少条数据
      6. 后端返回分页结果
         {
            "code": 200,
            "data": [ 当前页数据 ],
            "page": 1,
            "pageSize": 10,
            "total": 123
         }

## 前端收到分页数据后的流程
      1. 前端处理响应数据
         拿到data, total
      2. 前端渲染表格
         清理旧表格 -> 渲染当前页数据
      3. 前端计算总页数
         totalPages = ceil(total / pageSize)
      4. 前端渲染分页按钮
         上一页 | 1 | 2 | 3 | 下一页
         loadUserList(targetPage, pageSize)


   